import TS_AOC2018:Support:Guard;
import TS_AOC2018:Day;

class Day19 extends TS_AOC2018:Day
   method Day19();
   
   property string Description get;
   method SolvePart1() Returns string;
   method SolvePart2() Returns string;
   
   /* opcode functions */
   method addi(&a As number, &b As number, &c As number);
   method addr(&a As number, &b As number, &c As number);
   method muli(&a As number, &b As number, &c As number);
   method mulr(&a As number, &b As number, &c As number);
   method bani(&a As number, &b As number, &c As number);
   method banr(&a As number, &b As number, &c As number);
   method bori(&a As number, &b As number, &c As number);
   method borr(&a As number, &b As number, &c As number);
   method seti(&a As number, &b As number, &c As number);
   method setr(&a As number, &b As number, &c As number);
   
   method gtir(&a As number, &b As number, &c As number);
   method gtri(&a As number, &b As number, &c As number);
   method gtrr(&a As number, &b As number, &c As number);
   
   method eqir(&a As number, &b As number, &c As number);
   method eqri(&a As number, &b As number, &c As number);
   method eqrr(&a As number, &b As number, &c As number);
   
private
   method ParseInput();
   method RunInstruction();
   method RunProgram();
   /* bitwise helpers */
   method GetBits(&x As number) Returns array of any;
   method GetNumber(&bits As array of any) Returns number;
   method NormalizeBitCounts(&arr1 As array of any, &arr2 As array of any);
   method BitwiseAnd(&int1 As number, &int2 As number) Returns number;
   method BitwiseOr(&int1 As number, &int2 As number) Returns number;
   method BitAnd(&a As number, &b As number) Returns boolean;
   method BitOr(&a As number, &b As number) Returns boolean;
   
   instance array of number &registers;
   instance array of string &opCodes;
   instance array of array of number &parameters;
   instance number &ip;
   instance number &ipIndex;
end-class;

method Day19
   %Super = create TS_AOC2018:Day("TS_AOC_DAY19_INPUT");
   &registers = CreateArrayRept(0, 6);
   
end-method;

method ParseInput
   
   /* first line says which register will be IP */
   &ipIndex = Value(Substitute(%This.Lines [1], "#ip ", ""));
   
   &opCodes = CreateArrayRept("", 0);
   &parameters = CreateArrayRept(CreateArray(0), 0);
   Local integer &x;
   For &x = 2 To %This.Lines.Len
      Local array of string &instParts = Split(%This.Lines [&x], " ");
      &opCodes.Push(&instParts [1]);
      &parameters.Push(CreateArray(Value(&instParts [2]), Value(&instParts [3]), Value(&instParts [4])));
      
   End-For;
   
end-method;

method RunProgram
   While True
      /* run the instruction */
      %This.RunInstruction();
      If (&ip >= &opCodes.Len) Then
         /* we're outside of program space, break */
         Break;
      End-If;
      
   End-While;
   
end-method;

method RunInstruction
   
   /* write the IP to register */
   &registers [&ipIndex + 1] = &ip;
   
   Local string &opCode = &opCodes [&ip + 1];
   
   Evaluate &opCode
   When = "addi"
      %This.addi(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "addr"
      %This.addr(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "muli"
      %This.muli(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "mulr"
      %This.mulr(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "bani"
      %This.bani(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "banr"
      %This.banr(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "bori"
      %This.bori(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "borr"
      %This.borr(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "seti"
      %This.seti(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "setr"
      %This.setr(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "gtir"
      %This.gtir(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "gtri"
      %This.gtri(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "gtrr"
      %This.gtrr(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "eqir"
      %This.eqir(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "eqri"
      %This.eqri(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   When = "eqrr"
      %This.eqrr(&parameters [&ip + 1][1], &parameters [&ip + 1][2], &parameters [&ip + 1][3]);
      Break;
   End-Evaluate;
   
   /* read the IP from register */
   &ip = &registers [&ipIndex + 1];
   
   /* increment the IP */
   &ip = &ip + 1;
end-method;

method SolvePart1
   /+ Returns String +/
   /+ Extends/implements TS_AOC2018:Day.SolvePart1 +/
   %This.ParseInput();
   %This.RunProgram();
   Return String(&registers [1]);
end-method;

method SolvePart2
   /+ Returns String +/
   /+ Extends/implements TS_AOC2018:Day.SolvePart2 +/
   %This.ParseInput();
   
   /* to get a different initial number, we start with reg0 = 1 instead of 0 */
   &registers [1] = 1;
   
   /* The algorithm is the "sum of all divisors - we need to figure out the main number though*/
   /* because the init code is at the bottom, we'll run the program until we see our IP go backwards */
   Local integer &lastSeenIP = &ip;
   While True
      %This.RunInstruction();
      If (&ip > &lastSeenIP) Then
         &lastSeenIP = &ip;
      Else
         Break;
      End-If;
   End-While;
   
   /* init has happened and we jumped to the start of the program, assume the number is large */
   /* sort the registers in descending order */
   &registers.Sort("D");
   
   /* grab the largest one */
   Local number &bigNum = &registers [1];
   
   
   /* sum up all of the divisors */
   Local integer &x, &sum;
   For &x = 1 To &bigNum
      
      If (Mod(&bigNum, &x) = 0) Then
         &sum = &sum + &x;
      End-If;
      
   End-For;
   
   Return String(&sum);
end-method;

get Description
   /+ Returns String +/
   Return "Go With The Flow";
end-get;

method addi
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = &registers [&a + 1] + &b;
end-method;

method addr
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = &registers [&a + 1] + &registers [&b + 1];
end-method;

method muli
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = &registers [&a + 1] * &b;
end-method;

method mulr
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = &registers [&a + 1] * &registers [&b + 1];
end-method;

method bani
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = %This.BitwiseAnd(&registers [&a + 1], &b);
end-method;

method banr
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = %This.BitwiseAnd(&registers [&a + 1], &registers [&b + 1]);
end-method;

method bori
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = %This.BitwiseOr(&registers [&a + 1], &b);
end-method;

method borr
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = %This.BitwiseOr(&registers [&a + 1], &registers [&b + 1]);
end-method;

method seti
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = &a;
end-method;

method setr
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   &registers [&c + 1] = &registers [&a + 1];
end-method;

method gtir
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   If &a > &registers [&b + 1] Then
      &registers [&c + 1] = 1;
   Else
      &registers [&c + 1] = 0;
   End-If;
end-method;

method gtri
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   If &registers [&a + 1] > &b Then
      &registers [&c + 1] = 1;
   Else
      &registers [&c + 1] = 0;
   End-If;
end-method;

method gtrr
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   If &registers [&a + 1] > &registers [&b + 1] Then
      &registers [&c + 1] = 1;
   Else
      &registers [&c + 1] = 0;
   End-If;
end-method;

method eqir
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   If &a = &registers [&b + 1] Then
      &registers [&c + 1] = 1;
   Else
      &registers [&c + 1] = 0;
   End-If;
end-method;

method eqri
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   If &registers [&a + 1] = &b Then
      &registers [&c + 1] = 1;
   Else
      &registers [&c + 1] = 0;
   End-If;
end-method;

method eqrr
   /+ &a as Number, +/
   /+ &b as Number, +/
   /+ &c as Number +/
   If &registers [&a + 1] = &registers [&b + 1] Then
      &registers [&c + 1] = 1;
   Else
      &registers [&c + 1] = 0;
   End-If;
end-method;

method GetBits
   /+ &x as Number +/
   /+ Returns Array of Any +/
   Local array of any &bits = CreateArray();
   
   While (&x > 1)
      Local integer &bit = Mod(&x, 2);
      &bits.Push(&bit);
      &x = Idiv(&x, 2);
   End-While;
   If (&x = 1) Then
      &bits.Push(1);
   End-If;
   
   &bits.Reverse();
   
   Return &bits;
   
end-method;

method GetNumber
   /+ &bits as Array of Any +/
   /+ Returns Number +/
   Local integer &answer;
   
   Local integer &bit;
   
   Local integer &x;
   
   For &x = 1 To &bits.Len
      If (&bits [&x] = 1) Then
         &answer = &answer + 1;
      End-If;
      
      If (&x < &bits.Len) Then
         &answer = &answer * 2;
      End-If;
   End-For;
   Return &answer;
end-method;

method NormalizeBitCounts
   /+ &arr1 as Array of Any, +/
   /+ &arr2 as Array of Any +/
   If (&arr1.Len = &arr2.Len) Then
      Return;
   End-If;
   
   Local integer &maxLength = &arr1.Len;
   If (&arr2.Len > &maxLength) Then
      &maxLength = &arr2.Len;
   End-If;
   Local integer &x;
   If (&arr2.Len < &maxLength) Then
      &arr2.Reverse();
      For &x = 1 To &maxLength - &arr2.Len
         &arr2.Push(0);
         
      End-For;
      &arr2.Reverse();
   End-If;
   If (&arr1.Len < &maxLength) Then
      &arr1.Reverse();
      For &x = 1 To &maxLength - &arr1.Len
         &arr1.Push(0);
         
      End-For;
      &arr1.Reverse();
   End-If;
   
end-method;

method BitAnd
   /+ &a as Number, +/
   /+ &b as Number +/
   /+ Returns Boolean +/
   Return (&a = &b);
end-method;

method BitOr
   /+ &a as Number, +/
   /+ &b as Number +/
   /+ Returns Boolean +/
   Return (&a = 1 Or
      &b = 1);
end-method;

method BitwiseAnd
   /+ &int1 as Number, +/
   /+ &int2 as Number +/
   /+ Returns Number +/
   Local array of any &bits1 = %This.GetBits(&int1);
   Local array of any &bits2 = %This.GetBits(&int2);
   
   %This.NormalizeBitCounts(&bits1, &bits2);
   
   Local integer &x;
   
   Local array of any &andBits = CreateArray();
   Local integer &bitAnswer;
   For &x = 1 To &bits1.Len
      &bitAnswer = Value(%This.BitAnd(&bits1 [&x], &bits2 [&x]));
      &andBits.Push(&bitAnswer);
   End-For;
   
   
   Return %This.GetNumber(&andBits);
end-method;

method BitwiseOr
   /+ &int1 as Number, +/
   /+ &int2 as Number +/
   /+ Returns Number +/
   Local array of any &bits1 = %This.GetBits(&int1);
   Local array of any &bits2 = %This.GetBits(&int2);
   %This.NormalizeBitCounts(&bits1, &bits2);
   Local integer &x;
   
   Local array of any &orBits = CreateArray();
   Local integer &bitAnswer;
   For &x = 1 To &bits1.Len
      &bitAnswer = Value(%This.BitOr(&bits1 [&x], &bits2 [&x]));
      &orBits.Push(&bitAnswer);
   End-For;
   
   
   Return %This.GetNumber(&orBits);
end-method;

